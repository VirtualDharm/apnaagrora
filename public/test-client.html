<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Test Client - WebRTC</title>
  <script src="https://cdn.socket.io/4.8.1/socket.io.min.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      margin: 0;
      padding: 20px;
    }
    video {
      width: 45%;
      border-radius: 8px;
      border: 2px solid #ccc;
      margin: 5px;
    }
    .controls {
      margin-top: 15px;
    }
    input {
      width: 70%;
      padding: 8px;
      margin: 4px 0;
    }
    button {
      padding: 8px 16px;
      margin: 4px;
      cursor: pointer;
      border: none;
      border-radius: 6px;
      background-color: #007bff;
      color: white;
    }
    button:hover { background-color: #0056b3; }
    #logs {
      text-align: left;
      background: #f4f4f4;
      border-radius: 8px;
      padding: 10px;
      max-height: 200px;
      overflow-y: auto;
      margin-top: 15px;
    }
  </style>
</head>
<body>
  <h2>ðŸŽ¥ Test Client - WebRTC</h2>

  <div>
    <input id="roomId" placeholder="Room ID" />
    <input id="token" placeholder="JWT Token" />
    <div class="controls">
      <button id="connectBtn">Connect</button>
      <button id="shareScreenBtn">Share Screen</button>
      <button id="leaveBtn">Leave</button>
    </div>
  </div>

  <div>
    <video id="localVideo" autoplay muted playsinline></video>
    <video id="remoteVideo" autoplay playsinline></video>
  </div>

  <pre id="logs"></pre>

  <script>
    const base = location.origin;
    const log = (msg) => {
      const el = document.getElementById("logs");
      el.textContent += msg + "\n";
      el.scrollTop = el.scrollHeight;
      console.log(msg);
    };

    let socket, pc, localStream, screenStream;
    const connectBtn = document.getElementById("connectBtn");
    const leaveBtn = document.getElementById("leaveBtn");
    const shareScreenBtn = document.getElementById("shareScreenBtn");

    connectBtn.onclick = async () => {
      const roomId = document.getElementById("roomId").value.trim();
      const token = document.getElementById("token").value.trim();
      if (!roomId || !token) return alert("Room ID and token required");

      log(`Connecting to room ${roomId}...`);

      socket = io(base, { auth: { token } });

      socket.on("connect", async () => {
        log("âœ… Connected to signaling server");

        pc = new RTCPeerConnection({
          iceServers: [
            { urls: "stun:stun.l.google.com:19302" },
            { urls: "turn:your.turn.host:3478", username: "turnuser", credential: "turnpass" }
          ]
        });

        pc.onicecandidate = (e) => {
          if (e.candidate) socket.emit("ice-candidate", { candidate: e.candidate });
        };

        pc.ontrack = (e) => {
          document.getElementById("remoteVideo").srcObject = e.streams[0];
        };

        // Start camera
        localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
        document.getElementById("localVideo").srcObject = localStream;
        localStream.getTracks().forEach((t) => pc.addTrack(t, localStream));

        socket.on("offer", async ({ sdp, from }) => {
          log(`ðŸ“¨ Offer from ${from}`);
          await pc.setRemoteDescription(new RTCSessionDescription(sdp));
          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);
          socket.emit("answer", { sdp: answer });
        });

        socket.on("answer", async ({ sdp, from }) => {
          log(`ðŸ“¨ Answer from ${from}`);
          await pc.setRemoteDescription(new RTCSessionDescription(sdp));
        });

        socket.on("ice-candidate", async ({ candidate }) => {
          if (candidate) await pc.addIceCandidate(new RTCIceCandidate(candidate));
        });

        socket.on("user-joined", async ({ userId }) => {
          log(`ðŸ‘¤ ${userId} joined`);
          const offer = await pc.createOffer();
          await pc.setLocalDescription(offer);
          socket.emit("offer", { sdp: offer });
        });

        socket.on("user-left", ({ userId }) => log(`ðŸ‘‹ ${userId} left`));
        socket.on("room-closed", () => { log("ðŸš« Room closed"); cleanup(); });
      });

      socket.on("connect_error", (err) => log(`âŒ ${err.message}`));
    };

    // ðŸ“º Screen Sharing logic
    shareScreenBtn.onclick = async () => {
      if (!pc) return alert("Connect first!");

      if (!screenStream) {
        log("ðŸ” No active screen stream, initiating screen sharing");
        try {
            log("ðŸ“¡ Requesting display media with video: true");
            screenStream = await navigator.mediaDevices.getDisplayMedia({ video: true });
            log("âœ… Successfully obtained screen stream");

            const screenTrack = screenStream.getTracks()[0];
            log(`ðŸŽ¥ Screen track obtained: kind=${screenTrack.kind}, id=${screenTrack.id}, label=${screenTrack.label}`);

            const senders = pc.getSenders();
            log(`ðŸ”Ž Found ${senders.length} senders in peer connection`);
            const sender = senders.find(s => {
            const trackKind = s.track ? s.track.kind : 'none';
            log(`ðŸ” Checking sender: track kind=${trackKind}, id=${s.track?.id || 'none'}`);
            return s.track?.kind === "video";
            });
            
            if (!sender) {
            log("âŒ No video sender found in peer connection");
            throw new Error("No video sender found");
            }
            log(`âœ… Video sender found: track id=${sender.track?.id || 'none'}`);

            log("ðŸ”„ Replacing track with screen track");
            await sender.replaceTrack(screenTrack);
            log("âœ… Track replacement successful");

            log("ðŸ“º Setting local video element source to screen stream");
            const localVideoElement = document.getElementById("localVideo");
            if (!localVideoElement) {
            log("âŒ Local video element not found");
            throw new Error("Local video element not found");
            }
            localVideoElement.srcObject = screenStream;
            log("âœ… Local video element source set to screen stream");

            log("ðŸ–¥ï¸ Screen sharing started successfully");

            // Revert to camera when screen sharing stops
            screenTrack.onended = async () => {
            log("ðŸ›‘ Screen sharing ended event triggered");
            if (!localStream) {
                log("âŒ No local stream available to revert to");
                return;
            }

            const camTrack = localStream.getVideoTracks()[0];
            if (!camTrack) {
                log("âŒ No video track found in local stream");
                return;
            }
            log(`ðŸŽ¥ Camera track: kind=${camTrack.kind}, id=${camTrack.id}, label=${camTrack.label}`);

            const videoSender = pc.getSenders().find(s => s.track?.kind === "video");
            if (!videoSender) {
                log("âŒ No video sender found for reverting to camera");
                return;
            }

            log("ðŸ”„ Reverting to camera track");
            await videoSender.replaceTrack(camTrack);
            log("âœ… Successfully reverted to camera track");

            log("ðŸ“º Setting local video element source to camera stream");
            localVideoElement.srcObject = localStream;
            log("âœ… Local video element source set to camera stream");

            screenStream = null;
            log("ðŸ§¹ Screen stream cleared");
            };
        } catch (err) {
            log(`âŒ Screen share error: ${err.message}`);
            console.error("Detailed error:", err);
        }
        } else {
        log("ðŸ” Active screen stream detected, stopping screen sharing");
        const tracks = screenStream.getTracks();
        log(`ðŸ›‘ Stopping ${tracks.length} screen stream tracks`);
        tracks.forEach((t, index) => {
            log(`ðŸ›‘ Stopping track ${index + 1}: kind=${t.kind}, id=${t.id}, label=${t.label}`);
            t.stop();
            log(`âœ… Track ${index + 1} stopped`);
        });
        screenStream = null;
        log("ðŸ§¹ Screen stream cleared after manual stop");
        }
    };

    leaveBtn.onclick = () => {
      if (socket) {
        socket.disconnect();
        cleanup();
        log("ðŸ‘‹ Disconnected");
      }
    };

    function cleanup() {
      if (pc) pc.close();
      if (localStream) localStream.getTracks().forEach((t) => t.stop());
      if (screenStream) screenStream.getTracks().forEach((t) => t.stop());
    }
  </script>
</body>
</html>
